#include "main.h"
#include <cmath>
#include "lemlib/chassis/chassis.hpp"
#include "pros/adi.hpp"
#include "pros/misc.h"
#include "pros/motor_group.hpp"
#include "lemlib/api.hpp" // IWYU pragma: keep
#include "pros/motors.h"
#include "pros/rtos.hpp"
#include "pros/screen.h"
#include "odomreset_fixed.hpp"
#include "robot_states.hpp"
#include "auton_9blocks.hpp"
#include "auton_7blocks.hpp"
#include "auton_mid_low.hpp"
#include "auton_awp.hpp"
#include "auton_skills.hpp"
#include "odomreset_fixed.hpp"
#include "resetposition.hpp"
#define ENABLE_SKILLS_MACRO 0
#define ENABLE_AUTON_SELCTOR 0
enum Auton {
    SKILLS,
    LEFT_9BLOCKS,
    LEFT_7BLOCKS,
    LEFT_MIDGOAL_AND_LONG,
    LEFT_SNACKYAHH,
    RIGHT_9BLOCKS,
    RIGHT_LOWGOAL_AND_LONG,
    RIGHT_7BLOCKS,
    RIGHT_SAW_P
};

Auton selected_auton = SKILLS;

enum Screen { MAIN, SIDE, PROGRAM };

Screen current_screen = MAIN;

struct Button {
    int x1, y1, x2, y2;
    const char* text;
    Auton auton; // for program buttons
};

Button main_buttons[2] = {
    {50, 50, 200, 100, "Game Auton", (Auton)-1},
    {250, 50, 400, 100, "Skills", SKILLS}
};

Button side_buttons[2] = {
    {50, 50, 200, 100, "Left", (Auton)-1},
    {250, 50, 400, 100, "Right", (Auton)-1}
};

Button left_program_buttons[4] = {
    {50, 20, 350, 60, "9 Blocks", LEFT_9BLOCKS},
    {50, 70, 350, 110, "7 Blocks", LEFT_7BLOCKS},
    {50, 120, 350, 160, "Midgoal & Long", LEFT_MIDGOAL_AND_LONG},
    {50, 170, 350, 210, "Snacky Hard Carry", LEFT_SNACKYAHH}
};

Button right_program_buttons[4] = {
    {50, 20, 350, 60, "9 Blocks", RIGHT_9BLOCKS},
    {50, 70, 350, 110, "Lowgoal & Long", RIGHT_LOWGOAL_AND_LONG},
    {50, 120, 350, 160, "7 Blocks", RIGHT_7BLOCKS},
    {50, 170, 350, 210, "Solo AWP", RIGHT_SAW_P}
};

bool left_selected = false;

pros::Controller master(pros::E_CONTROLLER_MASTER);
pros::MotorGroup intake_mg({9});    // Creates a motor group with forwards ports 1 & 3 and reversed port 2
pros::MotorGroup scoring_mg({10});
pros::MotorGroup left_mg({-1, -2,11});  // Creates a motor group with forwards ports 4 & 5
pros::MotorGroup right_mg({5, 4,-8}); // Creates a motor group with
pros::adi::Pneumatics midgoal('G', false);
pros::adi::Pneumatics matchloader('A',false);
pros::adi::Pneumatics wings('F',false);
pros::adi::Pneumatics lowgoal('D',false);
pros::adi::Pneumatics midgoal_descore('H',false);
pros::Rotation vertical_encoder(-18);
lemlib::Drivetrain drivetrain(&left_mg,&right_mg,12,lemlib::Omniwheel::NEW_325,360,2);
pros::Imu imu(20);
lemlib::TrackingWheel vertical_tracking_wheel(&vertical_encoder, lemlib::Omniwheel::NEW_2,0);
lemlib::OdomSensors sensors(&vertical_tracking_wheel,nullptr,nullptr, nullptr,&imu);
// Distance sensor definitions (declared extern in odomreset.hpp)
pros::Distance distBack(13);
pros::Distance distLeft(12);
pros::Distance distRight(14);
	// lateral PID controller
lemlib::ControllerSettings lateral_controller(9.3, // proportional gain (kP)
                                              0, // integral gain (kI)
                                              8.56, // derivative gain (kD)
                                              3, // anti windup
                                              0.25, // small error range, in inches
                                              100, // small error range timeout, in milliseconds
                                              0.5, // large error range, in inches
                                              500, // large error range timeout, in milliseconds
                                              2// maximum acceleration (slew)
);

// angular PID controller
lemlib::ControllerSettings angular_controller(2.15, // proportional gain (kP)
                                              0, // integral gain (kI)
                                              15.55, // derivative gain (kD)
                                              3, // anti windup
                                              0.25, // small error range, in degrees
                                              100, // small error range timeout, in milliseconds
                                              0.5, // large error range, in degrees
                                              500, // large error range timeout, in milliseconds
                                              0 // maximum acceleration (slew)
);
lemlib::Chassis chassis(drivetrain, // drivetrain settings
    lateral_controller, // lateral PID settings
    angular_controller, // angular PID settings
    sensors // odometry sensors
);
void on_center_button() {
	static bool pressed = false;
	pressed = !pressed;
	if (pressed) {
		pros::lcd::set_text(2, "I was pressed!");
	} else {
		pros::lcd::clear_line(2);
	}
}




void initialize() {
	pros::lcd::initialize();
	chassis.calibrate();
}
void displayposition(){

	while(true){
		pros::lcd::print(0, "X: %f", chassis.getPose().x); // x
        pros::lcd::print(1, "Y: %f", chassis.getPose().y); // y
        pros::lcd::print(2, "Theta: %f", chassis.getPose().theta);
		pros::delay(50);
	}
}
/**
 * Runs while the robot is in the disabled state of Field Management System or
 * the VEX Competition Switch, following either autonomous or opcontrol. When
 * the robot is enabled, this task will exit.
 */
void disabled() {}

/**
 * Runs after initialize(), and before autonomous when connected to the Field
 * Management System or the VEX Competition Switch. This is intended for
 * competition-specific initialization routines, such as an autonomous selector
 * on the LCD.
 *
 * This task will exit when the robot is enabled and autonomous or opcontrol
 * starts.
 */
void competition_initialize() {
#if ENABLE_AUTON_SELCTOR
   while (true) {
        // Draw buttons based on current_screen
        if (current_screen == MAIN) {
            for (auto &btn : main_buttons) {
                pros::screen::set_pen(pros::c::COLOR_BLUE);
                pros::screen::fill_rect(btn.x1, btn.y1, btn.x2, btn.y2);
                pros::screen::set_pen(pros::c::COLOR_WHITE);
                pros::screen::draw_rect(btn.x1, btn.y1, btn.x2, btn.y2);
                pros::screen::print(TEXT_MEDIUM, btn.x1 + 10, btn.y1 + 20, btn.text);
            }
        } else if (current_screen == SIDE) {
            for (auto &btn : side_buttons) {
                pros::screen::set_pen(pros::c::COLOR_BLUE);
                pros::screen::fill_rect(btn.x1, btn.y1, btn.x2, btn.y2);
                pros::screen::set_pen(pros::c::COLOR_WHITE);
                pros::screen::draw_rect(btn.x1, btn.y1, btn.x2, btn.y2);
                pros::screen::print(TEXT_MEDIUM, btn.x1 + 10, btn.y1 + 20, btn.text);
            }
        } else if (current_screen == PROGRAM) {
            Button *buttons = left_selected ? left_program_buttons : right_program_buttons;
            for (int i = 0; i < 4; i++) {
                auto &btn = buttons[i];
                pros::screen::set_pen(pros::c::COLOR_BLUE);
                pros::screen::fill_rect(btn.x1, btn.y1, btn.x2, btn.y2);
                pros::screen::set_pen(pros::c::COLOR_WHITE);
                pros::screen::draw_rect(btn.x1, btn.y1, btn.x2, btn.y2);
                pros::screen::print(TEXT_MEDIUM, btn.x1 + 10, btn.y1 + 10, btn.text);
            }
        }

        // Check touch
        pros::screen_touch_status_s_t status = pros::screen::touch_status();
        if (status.touch_status == TOUCH_PRESSED || status.touch_status == TOUCH_HELD) {
            int x = status.x;
            int y = status.y;
            if (current_screen == MAIN) {
                for (auto &btn : main_buttons) {
                    if (x >= btn.x1 && x <= btn.x2 && y >= btn.y1 && y <= btn.y2) {
                        if (strcmp(btn.text, "Skills") == 0) {
                            selected_auton = SKILLS;
                            // Show selected
                            pros::screen::set_pen(pros::c::COLOR_BLACK);
                            pros::screen::fill_rect(0, 0, 480, 240);
                            pros::screen::set_pen(pros::c::COLOR_WHITE);
                            pros::screen::print(TEXT_MEDIUM, 100, 100, "Skills");
                            pros::delay(1000);
                            return; // exit
                        } else {
                            current_screen = SIDE;
                        }
                        pros::delay(200); // debounce
                        break;
                    }
                }
            } else if (current_screen == SIDE) {
                for (auto &btn : side_buttons) {
                    if (x >= btn.x1 && x <= btn.x2 && y >= btn.y1 && y <= btn.y2) {
                        left_selected = (strcmp(btn.text, "Left") == 0);
                        current_screen = PROGRAM;
